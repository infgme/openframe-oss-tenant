apiVersion: v1
kind: ConfigMap
metadata:
  name: alloy-config
data:
  config.alloy: |
    // ============================================================
    // SHARED DISCOVERY - Used by both logs and metrics pipelines
    // ============================================================
    discovery.kubernetes "pods" {
      role = "pod"
      selectors {
        role  = "pod"
        field = "spec.nodeName=" + sys.env("HOSTNAME")
      }
    }

    // ============================================================
    // LOGS PIPELINE
    // ============================================================
    discovery.relabel "pod_logs" {
      targets = discovery.kubernetes.pods.targets

      // Only scrape pods with loki annotation
      rule {
        source_labels = ["__meta_kubernetes_pod_annotation_loki_grafana_com_scrape"]
        regex         = "true"
        action        = "keep"
      }

      // Set log file path
      rule {
        source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
        target_label  = "__path__"
        separator     = "/"
        replacement   = "/var/log/pods/*$1/$2/*.log"
      }

      // Standard labels
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
      }
      rule {
        source_labels = ["__meta_kubernetes_pod_name"]
        target_label  = "pod"
      }
      rule {
        source_labels = ["__meta_kubernetes_pod_container_name"]
        target_label  = "container"
      }
      rule {
        source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
        target_label  = "app"
      }
    }

    // Collect logs from files
    local.file_match "pods" {
      path_targets = discovery.relabel.pod_logs.output
    }

    loki.source.file "pods" {
      targets    = local.file_match.pods.targets
      forward_to = [loki.process.pods.receiver]
    }

    // Process logs
    loki.process "pods" {
      forward_to = [loki.write.default.receiver]
      stage.cri {}
    }

    // Send logs to Loki
    loki.write "default" {
      endpoint {
        url               = {{ .Values.loki.url | quote }}
        batch_wait        = {{ .Values.loki.batchWait | quote }}
        batch_size        = {{ .Values.loki.batchSize | quote }}
        retry_on_http_429 = true
      }
    }

    // ============================================================
    // METRICS PIPELINE - Annotation-based pod scraping
    // Requires: prometheus.io/scrape: "true"
    // Optional: prometheus.io/port, prometheus.io/path
    // ============================================================
    discovery.relabel "pod_metrics" {
      targets = discovery.kubernetes.pods.targets

      // Only scrape pods with prometheus.io/scrape=true
      rule {
        source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_scrape"]
        regex         = "true"
        action        = "keep"
      }

      // Drop non-running pods
      rule {
        source_labels = ["__meta_kubernetes_pod_phase"]
        regex         = "Pending|Succeeded|Failed|Completed"
        action        = "drop"
      }

      // Use custom scheme if specified
      rule {
        source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_scheme"]
        action        = "replace"
        target_label  = "__scheme__"
        regex         = "(https?)"
      }

      // Use custom path if specified (default /metrics)
      rule {
        source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_path"]
        action        = "replace"
        target_label  = "__metrics_path__"
        regex         = "(.+)"
      }

      // Use custom port - handle IPv4
      rule {
        source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_port", "__meta_kubernetes_pod_ip"]
        action        = "replace"
        regex         = "(\\d+);((([0-9]+?)(\\.|$)){4})"
        replacement   = "$2:$1"
        target_label  = "__address__"
      }

      // Use custom port - handle IPv6
      rule {
        source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_port", "__meta_kubernetes_pod_ip"]
        action        = "replace"
        regex         = "(\\d+);(([A-Fa-f0-9]{1,4}::?){1,7}[A-Fa-f0-9]{1,4})"
        replacement   = "[$2]:$1"
        target_label  = "__address__"
      }

      // Copy pod labels
      rule {
        action = "labelmap"
        regex  = "__meta_kubernetes_pod_label_(.+)"
      }

      // Add namespace label
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
      }

      // Add pod label
      rule {
        source_labels = ["__meta_kubernetes_pod_name"]
        target_label  = "pod"
      }

      // Add container label
      rule {
        source_labels = ["__meta_kubernetes_pod_container_name"]
        target_label  = "container"
      }

      // Add node label
      rule {
        source_labels = ["__meta_kubernetes_pod_node_name"]
        target_label  = "node"
      }
    }

    // Scrape metrics from discovered pods
    prometheus.scrape "pods" {
      targets         = discovery.relabel.pod_metrics.output
      scrape_interval = {{ .Values.prometheus.scrapeInterval | quote }}
      scrape_timeout  = {{ .Values.prometheus.scrapeTimeout | quote }}
      forward_to      = [prometheus.relabel.filter.receiver]
    }

    // ============================================================
    // CADVISOR METRICS (Container CPU/Memory)
    // ============================================================
    discovery.kubernetes "nodes" {
      role = "node"
    }

    discovery.relabel "cadvisor" {
      targets = discovery.kubernetes.nodes.targets

      rule {
        action = "labelmap"
        regex  = "__meta_kubernetes_node_label_(.+)"
      }

      rule {
        target_label = "__address__"
        replacement  = "kubernetes.default.svc:443"
      }

      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        regex         = "(.+)"
        target_label  = "__metrics_path__"
        replacement   = "/api/v1/nodes/$1/proxy/metrics/cadvisor"
      }
    }

    prometheus.scrape "cadvisor" {
      targets         = discovery.relabel.cadvisor.output
      scheme          = "https"
      scrape_interval = {{ .Values.prometheus.scrapeInterval | quote }}
      scrape_timeout  = {{ .Values.prometheus.scrapeTimeout | quote }}

      bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
      tls_config {
        ca_file              = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
        insecure_skip_verify = true
      }

      forward_to = [prometheus.relabel.cadvisor.receiver]
    }

    prometheus.relabel "cadvisor" {
      // Keep only CPU and memory metrics
      rule {
        source_labels = ["__name__"]
        regex         = "container_cpu_usage_seconds_total|container_memory_working_set_bytes"
        action        = "keep"
      }

      // Filter to relevant namespaces
      rule {
        source_labels = ["namespace"]
        regex         = {{ .Values.prometheus.namespaceFilter | quote }}
        action        = "keep"
      }

      forward_to = [prometheus.remote_write.prometheus.receiver]
    }

    // ============================================================
    // KUBELET METRICS (PVC Storage)
    // ============================================================
    discovery.relabel "kubelet" {
      targets = discovery.kubernetes.nodes.targets

      rule {
        action = "labelmap"
        regex  = "__meta_kubernetes_node_label_(.+)"
      }

      rule {
        target_label = "__address__"
        replacement  = "kubernetes.default.svc:443"
      }

      rule {
        source_labels = ["__meta_kubernetes_node_name"]
        regex         = "(.+)"
        target_label  = "__metrics_path__"
        replacement   = "/api/v1/nodes/$1/proxy/metrics"
      }
    }

    prometheus.scrape "kubelet" {
      targets         = discovery.relabel.kubelet.output
      scheme          = "https"
      scrape_interval = {{ .Values.prometheus.scrapeInterval | quote }}
      scrape_timeout  = {{ .Values.prometheus.scrapeTimeout | quote }}

      bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
      tls_config {
        ca_file              = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
        insecure_skip_verify = true
      }

      forward_to = [prometheus.relabel.kubelet.receiver]
    }

    prometheus.relabel "kubelet" {
      // Keep only PVC storage metrics
      rule {
        source_labels = ["__name__"]
        regex         = "kubelet_volume_stats_used_bytes|kubelet_volume_stats_capacity_bytes"
        action        = "keep"
      }

      // Filter to relevant namespaces
      rule {
        source_labels = ["namespace"]
        regex         = {{ .Values.prometheus.namespaceFilter | quote }}
        action        = "keep"
      }

      forward_to = [prometheus.remote_write.prometheus.receiver]
    }

    // ============================================================
    // METRICS FILTERING & REMOTE WRITE TO PROMETHEUS
    // ============================================================
    prometheus.relabel "filter" {
      // Drop high-cardinality internal metrics
      rule {
        source_labels = ["__name__"]
        regex         = "go_gc_.*|go_memstats_.*"
        action        = "drop"
      }

      // Drop Cilium metrics (high cardinality, unused)
      rule {
        source_labels = ["__name__"]
        regex         = "cilium_.*"
        action        = "drop"
      }

      forward_to = [prometheus.remote_write.prometheus.receiver]
    }

    // Send metrics to Prometheus via remote write
    prometheus.remote_write "prometheus" {
      endpoint {
        url = {{ .Values.prometheus.remoteWriteUrl | quote }}

        queue_config {
          max_shards           = 10
          max_samples_per_send = 2000
          batch_send_deadline  = "5s"
        }
      }

      wal {
        truncate_frequency = "2h"
        max_keepalive_time = "8h"
      }
    }
