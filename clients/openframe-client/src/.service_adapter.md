<!-- source-hash: 54a9ee29ce147b59e10b20619a824f71 -->
A cross-platform service management adapter that provides a unified interface for installing, managing, and configuring system services across Windows, macOS, and Linux platforms.

## Key Components

### ServiceConfig
Configuration structure containing all service parameters including:
- Basic service information (name, display name, description, executable path)
- Process control settings (auto-start, keep alive, restart behavior)
- Environment variables and working directory
- Logging configuration (stdout/stderr paths)
- User/group identity settings
- Resource limits and timeouts

### CrossPlatformServiceManager
Main service management interface providing:
- `new()` - Creates a service manager with basic configuration
- `with_config()` - Creates from a complete ServiceConfig
- Configuration setters (stdout/stderr paths, user/group, timeouts)
- Core operations: `install()`, `uninstall()`, `start()`, `stop()`
- Platform-specific configuration handling

## Usage Example

```rust
use std::path::PathBuf;

// Create a service manager
let mut service = CrossPlatformServiceManager::new(
    "myapp",
    "My Application Service",
    "A sample service for demonstration",
    PathBuf::from("/usr/local/bin/myapp")
);

// Configure logging and runtime settings
service
    .set_stdout_path(PathBuf::from("/var/log/myapp.log"))
    .set_stderr_path(PathBuf::from("/var/log/myapp.err"))
    .set_user("myappuser")
    .set_restart_throttle(30);

// Install and start the service
service.install()?;

// Later, stop and uninstall
service.stop()?;
service.uninstall()?;
```

The adapter handles platform-specific differences automatically, including Windows service registration, macOS launchd plist generation, and Linux systemd unit file creation.